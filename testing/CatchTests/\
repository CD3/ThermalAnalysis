#include "catch.hpp"

#include <cmath>
#include <iostream>
#include <libField/Field.hpp>
using namespace std;

// Writing an implementation, in plain english this implementation needs to:
// have a function add to add (function? field?) values to some container in
// mem, to be stored. There also needs a build method that will assign (not
// return) to an argument (so it must be passed by reference) a Profile
// (field?). It cannot directly add, so the interpolation library (what and
// where is it, must be \#included. Think numpy vector operations but in a real
// physical sense, keeping in mind that these array values show part of a
// larger continuous curve. What should the updated resolution of the field be?
// Be general, not just geometric time spacing may be used
class LinearCombination
{
 public:
  //look into what templates are? do I have to make some connection between these template types and true types or is it trickery like 'auto?'
  vector<Field<double, 1>> profiles;

  template <typename F, typename T, typename S>
  //class variable G?
  //vector<F> id;
  void add(const F& field, T t, S scale)
  {
    profiles = profiles;
    profiles.resize(profiles.size());
    profiles[profiles.size() - 1] = field;
    std::cout << "ANY STRING!";
  }

  template <typename F>
  void build(F& field)
  {
    profiles[0];
    profiles[1];//if this doesn't fail, both exist: good!
    //"sort the actual t values. so if you have them in order from smallest to
    //largest, provide indexes 0-n, but maintain some relation from the new
    //thing to the old field. Now interpolate ALL original fields. For every
    //value in the sorted time list that they do not already have a value for,
    //insert a value taken from the interpolated
    //
    //Pseudo:
    //1. initialize a vector for the time(t) and power(P) represented by each index in each field in add, and store them (still 2 dim? maybe 3?), should be 1-1
    //2. Combine the lists and sort them but keep track of where i goes (NEEDS MORE ALGORITHMIC ANSWER, MORE LONGFORM)
    //3. Establish lower and upper bounds (j/t, based on clark's answer to "how are these arrays sized?"
    //4. initialize "final field"
    //5. for each j in sorted list,
    //5.a    running_p_sum = 0
    //5.a    iterate through each index(i) in the map (2.) - (corresponding to every field in profiles)
    //5.b       if map[i][j] exists:
    //5.c         profiles[i] -> curr_field
    //5.c         map[i][j]   -> i_val in profiles[i], k (discrete power)
    //5.c         t_list = profiles[i]
    //5.c         p_list = profiles[i]
    //5.c         t = t_list[k]
    //5.c         p = p_list[k]
    //5.c         running_p_sum += p
    int n = 0;
    for(int i = 0; i < profiles.size(); i++){
      n += profiles[i].size();
    }
    double timeArr[n];
    double tempArr[n];
    int indexArr[n];
    for(int i = 0; i < profiles.size(); i++){
      double sum = 0.0;
      Field<double, 1> curr_field = profiles[i];
      for(int j = 0; j < curr_field.size() - 1; j++){
        double time;
        double temper;
        if(i == j){
          
          continue;
        } else {
          time = curr_field.getCoord(j + 1);
          time_prev = curr_field.getCoord(j);
          if(time < time_prev){
          time = curr_field.getCoord(j + 1)[0];
          }
        }
      }
      auto f_prime = profiles[i];
    }
    field.set_f([](auto t) {
      return (t[0] >= 2) ? sqrt(t[0] / M_PI) - sqrt((t[0] - 2) / M_PI)
                       : sqrt(t[0] / M_PI);
    });
  }
};

TEST_CASE("TempBuilder Tests")
{
  SECTION("Analytic Temperature Profile")
  {
    //Tinf seems to be a mapping that is useful?
    auto Tinf = [](double t) -> double {
      return sqrt(t / M_PI);
    };  // see LinearCombinations write up
    SECTION("Building finite-pulse profile")
    {
      std::cout << "TEST";
      // setup thermal profile we will build off of.
      //Tinf_vs_t is a FIELD
      //Tempbuilder is a LINEARCOMBINATINO (METHOD IM DEFINING)
      Field<double, 1> Tinf_vs_t(100);
      Tinf_vs_t.setCoordinateSystem(Geometric<double>(0, 0.1, 1.05));
      //what is the best way to include this^^ in method? not include it at
      //all, make it figure it out
      //just know it sets heat values
      Tinf_vs_t.set_f([&Tinf](auto t) -> double { return Tinf(t[0]); });

      // setup thermal profile that will be written to
      Field<double, 1> T1_vs_t(100);
      T1_vs_t.setCoordinateSystem(Uniform<double>(0, 5));

      // magic...
      // something like
      LinearCombination tempBuilder;

      tempBuilder.add(Tinf_vs_t, 0, 1);
      tempBuilder.add(Tinf_vs_t, 2, -1);

      tempBuilder.build(T1_vs_t);//by ref

      for (int i = 0; i < 100; ++i) {
        double dt = 5. / (100 - 1);
        double t = i * dt;
        CHECK(T1_vs_t.getCoord(i) == Approx(t));
        if (t < 2) {
          CHECK(T1_vs_t(i) == Approx(Tinf(t)));
        } else {
          CHECK(T1_vs_t(i) == Approx(Tinf(t) - Tinf(t - 2)));
        }
      }
    }
  }
}
